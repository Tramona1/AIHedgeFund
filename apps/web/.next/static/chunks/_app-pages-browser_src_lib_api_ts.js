"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunk_N_E"] = globalThis["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_api_ts"],{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aiTriggersAPI: () => (/* binding */ aiTriggersAPI),\n/* harmony export */   economicReportsAPI: () => (/* binding */ economicReportsAPI),\n/* harmony export */   interviewsAPI: () => (/* binding */ interviewsAPI),\n/* harmony export */   stockUpdatesAPI: () => (/* binding */ stockUpdatesAPI),\n/* harmony export */   userPreferencesAPI: () => (/* binding */ userPreferencesAPI)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../../node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\");\n// API service for interacting with the backend\n/**\n * Next.js provides fetch globally in both client and server components.\n * If you encounter \"fetch is not defined\" errors:\n * 1. Check that you're using Next.js correctly\n * 2. Ensure you have the correct environment setup\n * 3. For non-Next.js environments, consider adding:\n *    import 'isomorphic-fetch'; or import 'cross-fetch';\n */ /**\n * Base API URL from environment variable or fallback to localhost in development\n */ const API_BASE_URL = (()=>{\n    // Use environment variable if defined\n    if (process.env.NEXT_PUBLIC_API_URL) {\n        return process.env.NEXT_PUBLIC_API_URL;\n    }\n    // In browser environment, detect the current URL and port\n    if (true) {\n        // Get the current hostname (allows for testing on other devices on the network)\n        const hostname = window.location.hostname;\n        // Always use the fixed API port in development\n        return \"http://\".concat(hostname, \":3002\");\n    }\n    // Default fallback for server-side\n    return 'http://localhost:3002';\n})();\n/**\n * Generic API fetcher with error handling\n */ async function fetchAPI(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const url = \"\".concat(API_BASE_URL).concat(endpoint);\n    try {\n        console.log(\"Fetching from: \".concat(url));\n        const response = await fetch(url, {\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options.headers\n            }\n        });\n        if (!response.ok) {\n            let errorData;\n            try {\n                errorData = await response.json();\n            } catch (e) {\n                errorData = {\n                    message: \"HTTP error \".concat(response.status)\n                };\n            }\n            throw new Error(errorData.message || \"API error: \".concat(response.status));\n        }\n        return response.json();\n    } catch (error) {\n        console.error(\"Failed to fetch from \".concat(url, \":\"), error);\n        // Add more context to the error\n        if (error instanceof TypeError && error.message === 'Failed to fetch') {\n            throw new Error(\"Network error: Could not connect to API at \".concat(API_BASE_URL, \". Please ensure the API server is running.\"));\n        }\n        // Re-throw to allow components to handle the error\n        throw error;\n    }\n}\n/**\n * Stock Updates API\n */ const stockUpdatesAPI = {\n    /**\n   * Get all stock updates\n   */ getAll: ()=>fetchAPI('/api/updates'),\n    /**\n   * Get stock updates for a specific ticker\n   */ getByTicker: (ticker)=>fetchAPI(\"/api/updates/ticker/\".concat(ticker)),\n    /**\n   * Create a new stock update (admin only in production)\n   */ create: (data)=>fetchAPI('/api/updates', {\n            method: 'POST',\n            body: JSON.stringify(data)\n        })\n};\n/**\n * User Preferences API\n */ const userPreferencesAPI = {\n    async get (userId) {\n        try {\n            if (!userId) {\n                console.warn('Attempted to fetch user preferences without a user ID');\n                return {\n                    userPreferences: null\n                };\n            }\n            return await fetchAPI(\"/api/users/\".concat(userId, \"/preferences\"));\n        } catch (error) {\n            console.error('Error fetching user preferences:', error);\n            // If it's a \"User not found\" error, this might be a new user\n            if (error instanceof Error && error.message === 'User not found') {\n                console.log('This appears to be a new user - returning empty preferences');\n                // Return empty result for new users instead of propagating the error\n                return {\n                    userPreferences: null\n                };\n            }\n            // Return empty result for all errors instead of propagating\n            return {\n                userPreferences: null\n            };\n        }\n    },\n    async update (data) {\n        try {\n            // Add retry logic for when the server might be starting up\n            const maxRetries = 3;\n            let lastError = null;\n            for(let attempt = 1; attempt <= maxRetries; attempt++){\n                try {\n                    const result = await fetchAPI(\"/api/users/\".concat(data.userId, \"/preferences\"), {\n                        method: 'POST',\n                        body: JSON.stringify(data)\n                    });\n                    return result;\n                } catch (err) {\n                    console.log(\"API call attempt \".concat(attempt, \" failed:\"), err);\n                    lastError = err;\n                    // Only retry on network errors, not on API errors\n                    if (!(err instanceof TypeError) || attempt === maxRetries) {\n                        throw err;\n                    }\n                    // Wait between retries (exponential backoff)\n                    await new Promise((r)=>setTimeout(r, 1000 * attempt));\n                }\n            }\n            throw lastError;\n        } catch (error) {\n            console.error('Error updating user preferences:', error);\n            throw error;\n        }\n    }\n};\n/**\n * AI Triggers API (for demonstration purposes - in production this would be restricted)\n */ const aiTriggersAPI = {\n    /**\n   * Get AI triggers for a specific ticker\n   */ getByTicker: (ticker)=>fetchAPI(\"/api/ai-triggers/\".concat(ticker)),\n    /**\n   * Send a test notification (development only)\n   */ sendTestNotification: (data)=>fetchAPI('/api/notifications/test', {\n            method: 'POST',\n            body: JSON.stringify(data)\n        }),\n    /**\n   * Create a test AI trigger (development/demo purposes only)\n   */ createTestTrigger: (data)=>fetchAPI('/api/ai-triggers/test', {\n            method: 'POST',\n            body: JSON.stringify(data)\n        })\n};\n/**\n * Economic Reports API\n */ const economicReportsAPI = {\n    /**\n   * Get recent economic reports\n   */ getRecent: function() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n        return fetchAPI(\"/api/economic-reports/recent?limit=\".concat(limit));\n    },\n    /**\n   * Get economic reports by source\n   */ getBySource: function(source) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        return fetchAPI(\"/api/economic-reports/recent?source=\".concat(source, \"&limit=\").concat(limit));\n    },\n    /**\n   * Get economic reports by category\n   */ getByCategory: function(category) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        return fetchAPI(\"/api/economic-reports/recent?category=\".concat(category, \"&limit=\").concat(limit));\n    },\n    /**\n   * Get available economic report sources\n   */ getSources: ()=>fetchAPI('/api/economic-reports/sources'),\n    /**\n   * Get available economic report categories\n   */ getCategories: ()=>fetchAPI('/api/economic-reports/categories')\n};\n/**\n * Interviews API\n */ const interviewsAPI = {\n    /**\n   * Get recent interviews\n   */ getRecent: function() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n        return fetchAPI(\"/api/interviews/recent?limit=\".concat(limit));\n    },\n    /**\n   * Get interviews by speaker\n   */ getBySpeaker: function(speaker) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        return fetchAPI(\"/api/interviews/recent?speaker=\".concat(speaker, \"&limit=\").concat(limit));\n    },\n    /**\n   * Get available interview speakers\n   */ getSpeakers: ()=>fetchAPI('/api/interviews/speakers')\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFO0FBRUY7O0NBRUMsR0FDTSxNQUFNc0IscUJBQXFCO0lBQ2hDOztHQUVDLEdBQ0RDLFdBQVc7WUFBQ0MseUVBQVE7ZUFDbEIvQyxTQUFxQyxzQ0FBNEMsT0FBTitDOztJQUU3RTs7R0FFQyxHQUNEQyxhQUFhLFNBQUNDO1lBQWdCRix5RUFBUTtlQUNwQy9DLFNBQXFDLHVDQUF1RCtDLE9BQWhCRSxRQUFPLFdBQWUsT0FBTkY7O0lBRTlGOztHQUVDLEdBQ0RHLGVBQWUsU0FBQ0M7WUFBa0JKLHlFQUFRO2VBQ3hDL0MsU0FBcUMseUNBQTJEK0MsT0FBbEJJLFVBQVMsV0FBZSxPQUFOSjs7SUFFbEc7O0dBRUMsR0FDREssWUFBWSxJQUNWcEQsU0FBNkI7SUFFL0I7O0dBRUMsR0FDRHFELGVBQWUsSUFDYnJELFNBQTZCO0FBQ2pDLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU1zRCxnQkFBZ0I7SUFDM0I7O0dBRUMsR0FDRFIsV0FBVztZQUFDQyx5RUFBUTtlQUNsQi9DLFNBQWdDLGdDQUFzQyxPQUFOK0M7O0lBRWxFOztHQUVDLEdBQ0RRLGNBQWMsU0FBQ0M7WUFBaUJULHlFQUFRO2VBQ3RDL0MsU0FBZ0Msa0NBQW1EK0MsT0FBakJTLFNBQVEsV0FBZSxPQUFOVDs7SUFFckY7O0dBRUMsR0FDRFUsYUFBYSxJQUNYekQsU0FBNkI7QUFDakMsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL2JsYWtlc2luZ2xldG9uL0Rlc2t0b3AvQUlIZWRnZUZ1bmQvYXBwcy93ZWIvc3JjL2xpYi9hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQVBJIHNlcnZpY2UgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIGJhY2tlbmRcblxuLyoqXG4gKiBOZXh0LmpzIHByb3ZpZGVzIGZldGNoIGdsb2JhbGx5IGluIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIgY29tcG9uZW50cy5cbiAqIElmIHlvdSBlbmNvdW50ZXIgXCJmZXRjaCBpcyBub3QgZGVmaW5lZFwiIGVycm9yczpcbiAqIDEuIENoZWNrIHRoYXQgeW91J3JlIHVzaW5nIE5leHQuanMgY29ycmVjdGx5XG4gKiAyLiBFbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgZW52aXJvbm1lbnQgc2V0dXBcbiAqIDMuIEZvciBub24tTmV4dC5qcyBlbnZpcm9ubWVudHMsIGNvbnNpZGVyIGFkZGluZzpcbiAqICAgIGltcG9ydCAnaXNvbW9ycGhpYy1mZXRjaCc7IG9yIGltcG9ydCAnY3Jvc3MtZmV0Y2gnO1xuICovXG5cbi8qKlxuICogQmFzZSBBUEkgVVJMIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGUgb3IgZmFsbGJhY2sgdG8gbG9jYWxob3N0IGluIGRldmVsb3BtZW50XG4gKi9cbmNvbnN0IEFQSV9CQVNFX1VSTCA9ICgoKSA9PiB7XG4gIC8vIFVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpZiBkZWZpbmVkXG4gIGlmIChwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkw7XG4gIH1cbiAgXG4gIC8vIEluIGJyb3dzZXIgZW52aXJvbm1lbnQsIGRldGVjdCB0aGUgY3VycmVudCBVUkwgYW5kIHBvcnRcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IGhvc3RuYW1lIChhbGxvd3MgZm9yIHRlc3Rpbmcgb24gb3RoZXIgZGV2aWNlcyBvbiB0aGUgbmV0d29yaylcbiAgICBjb25zdCBob3N0bmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAvLyBBbHdheXMgdXNlIHRoZSBmaXhlZCBBUEkgcG9ydCBpbiBkZXZlbG9wbWVudFxuICAgIHJldHVybiBgaHR0cDovLyR7aG9zdG5hbWV9OjMwMDJgO1xuICB9XG4gIFxuICAvLyBEZWZhdWx0IGZhbGxiYWNrIGZvciBzZXJ2ZXItc2lkZVxuICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMic7XG59KSgpO1xuXG4vKipcbiAqIEdlbmVyaWMgQVBJIGZldGNoZXIgd2l0aCBlcnJvciBoYW5kbGluZ1xuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaEFQSTxUPihcbiAgZW5kcG9pbnQ6IHN0cmluZywgXG4gIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge31cbik6IFByb21pc2U8VD4ge1xuICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRV9VUkx9JHtlbmRwb2ludH1gO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgZnJvbTogJHt1cmx9YCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JEYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvckRhdGEgPSB7IG1lc3NhZ2U6IGBIVFRQIGVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfWAgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBmZXRjaCBmcm9tICR7dXJsfTpgLCBlcnJvcik7XG4gICAgLy8gQWRkIG1vcmUgY29udGV4dCB0byB0aGUgZXJyb3JcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgZXJyb3IubWVzc2FnZSA9PT0gJ0ZhaWxlZCB0byBmZXRjaCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayBlcnJvcjogQ291bGQgbm90IGNvbm5lY3QgdG8gQVBJIGF0ICR7QVBJX0JBU0VfVVJMfS4gUGxlYXNlIGVuc3VyZSB0aGUgQVBJIHNlcnZlciBpcyBydW5uaW5nLmApO1xuICAgIH1cbiAgICAvLyBSZS10aHJvdyB0byBhbGxvdyBjb21wb25lbnRzIHRvIGhhbmRsZSB0aGUgZXJyb3JcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIFR5cGVzIGJhc2VkIG9uIG91ciBiYWNrZW5kIG1vZGVsc1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RvY2tVcGRhdGUge1xuICBpZDogc3RyaW5nO1xuICB0aWNrZXI6IHN0cmluZztcbiAgZXZlbnRUeXBlOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgZGV0YWlscz86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIHNvdXJjZT86IHN0cmluZztcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlclByZWZlcmVuY2VzIHtcbiAgaWQ6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHRpY2tlcnM/OiBzdHJpbmdbXTtcbiAgc2VjdG9ycz86IHN0cmluZ1tdO1xuICB0cmFkaW5nU3R5bGU/OiBzdHJpbmc7XG4gIHVwZGF0ZUZyZXF1ZW5jeTogJ2RhaWx5JyB8ICd3ZWVrbHknIHwgJ3JlYWx0aW1lJztcbiAgY3VzdG9tVHJpZ2dlcnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgdXBkYXRlZEF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWNvbm9taWNSZXBvcnQge1xuICBpZDogc3RyaW5nO1xuICBzb3VyY2U6IHN0cmluZztcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAgb3JpZ2luYWxfZmlsZW5hbWU/OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogc3RyaW5nO1xuICBzdWJqZWN0Pzogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG4gIHN1bW1hcnk/OiBzdHJpbmc7XG4gIGZpbGVfdXJsOiBzdHJpbmc7XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIGZyb21fZW1haWw/OiBzdHJpbmc7XG4gIHByb2Nlc3NlZF9hdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEludGVydmlldyB7XG4gIGlkOiBzdHJpbmc7XG4gIHZpZGVvX2lkOiBzdHJpbmc7XG4gIHZpZGVvX3VybDogc3RyaW5nO1xuICB0aXRsZT86IHN0cmluZztcbiAgc3BlYWtlcj86IHN0cmluZztcbiAgdGltZXN0YW1wOiBzdHJpbmc7XG4gIHN1bW1hcnk/OiBzdHJpbmc7XG4gIGhpZ2hsaWdodHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICB0cmFuc2NyaXB0X3VybD86IHN0cmluZztcbiAgcHJvY2Vzc2VkX2F0OiBzdHJpbmc7XG59XG5cbi8qKlxuICogU3RvY2sgVXBkYXRlcyBBUElcbiAqL1xuZXhwb3J0IGNvbnN0IHN0b2NrVXBkYXRlc0FQSSA9IHtcbiAgLyoqXG4gICAqIEdldCBhbGwgc3RvY2sgdXBkYXRlc1xuICAgKi9cbiAgZ2V0QWxsOiAoKSA9PiBcbiAgICBmZXRjaEFQSTx7IHVwZGF0ZXM6IFN0b2NrVXBkYXRlW10gfT4oJy9hcGkvdXBkYXRlcycpLFxuICAgIFxuICAvKipcbiAgICogR2V0IHN0b2NrIHVwZGF0ZXMgZm9yIGEgc3BlY2lmaWMgdGlja2VyXG4gICAqL1xuICBnZXRCeVRpY2tlcjogKHRpY2tlcjogc3RyaW5nKSA9PiBcbiAgICBmZXRjaEFQSTx7IHVwZGF0ZXM6IFN0b2NrVXBkYXRlW10gfT4oYC9hcGkvdXBkYXRlcy90aWNrZXIvJHt0aWNrZXJ9YCksXG4gICAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc3RvY2sgdXBkYXRlIChhZG1pbiBvbmx5IGluIHByb2R1Y3Rpb24pXG4gICAqL1xuICBjcmVhdGU6IChkYXRhOiBPbWl0PFN0b2NrVXBkYXRlLCAnaWQnIHwgJ2NyZWF0ZWRBdCc+KSA9PiBcbiAgICBmZXRjaEFQSTx7IGlkOiBzdHJpbmcgfT4oJy9hcGkvdXBkYXRlcycsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSksXG59O1xuXG4vKipcbiAqIFVzZXIgUHJlZmVyZW5jZXMgQVBJXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VyUHJlZmVyZW5jZXNBUEkgPSB7XG4gIGFzeW5jIGdldCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8eyB1c2VyUHJlZmVyZW5jZXM6IFVzZXJQcmVmZXJlbmNlcyB8IG51bGwgfT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0F0dGVtcHRlZCB0byBmZXRjaCB1c2VyIHByZWZlcmVuY2VzIHdpdGhvdXQgYSB1c2VyIElEJyk7XG4gICAgICAgIHJldHVybiB7IHVzZXJQcmVmZXJlbmNlczogbnVsbCB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2hBUEk8eyB1c2VyUHJlZmVyZW5jZXM6IFVzZXJQcmVmZXJlbmNlcyB8IG51bGwgfT4oYC9hcGkvdXNlcnMvJHt1c2VySWR9L3ByZWZlcmVuY2VzYCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHVzZXIgcHJlZmVyZW5jZXM6JywgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBJZiBpdCdzIGEgXCJVc2VyIG5vdCBmb3VuZFwiIGVycm9yLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHVzZXJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UgPT09ICdVc2VyIG5vdCBmb3VuZCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgYXBwZWFycyB0byBiZSBhIG5ldyB1c2VyIC0gcmV0dXJuaW5nIGVtcHR5IHByZWZlcmVuY2VzJyk7XG4gICAgICAgIC8vIFJldHVybiBlbXB0eSByZXN1bHQgZm9yIG5ldyB1c2VycyBpbnN0ZWFkIG9mIHByb3BhZ2F0aW5nIHRoZSBlcnJvclxuICAgICAgICByZXR1cm4geyB1c2VyUHJlZmVyZW5jZXM6IG51bGwgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIGVtcHR5IHJlc3VsdCBmb3IgYWxsIGVycm9ycyBpbnN0ZWFkIG9mIHByb3BhZ2F0aW5nXG4gICAgICByZXR1cm4geyB1c2VyUHJlZmVyZW5jZXM6IG51bGwgfTtcbiAgICB9XG4gIH0sXG4gIFxuICBhc3luYyB1cGRhdGUoZGF0YTogUGFydGlhbDxVc2VyUHJlZmVyZW5jZXM+KTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgcmV0cnkgbG9naWMgZm9yIHdoZW4gdGhlIHNlcnZlciBtaWdodCBiZSBzdGFydGluZyB1cFxuICAgICAgY29uc3QgbWF4UmV0cmllcyA9IDM7XG4gICAgICBsZXQgbGFzdEVycm9yOiBhbnkgPSBudWxsO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEFQSTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U/OiBzdHJpbmcgfT4oYC9hcGkvdXNlcnMvJHtkYXRhLnVzZXJJZH0vcHJlZmVyZW5jZXNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBBUEkgY2FsbCBhdHRlbXB0ICR7YXR0ZW1wdH0gZmFpbGVkOmAsIGVycik7XG4gICAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE9ubHkgcmV0cnkgb24gbmV0d29yayBlcnJvcnMsIG5vdCBvbiBBUEkgZXJyb3JzXG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB8fCBhdHRlbXB0ID09PSBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiByZXRyaWVzIChleHBvbmVudGlhbCBiYWNrb2ZmKVxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCAxMDAwICogYXR0ZW1wdCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGxhc3RFcnJvcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdXNlciBwcmVmZXJlbmNlczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQUkgVHJpZ2dlcnMgQVBJIChmb3IgZGVtb25zdHJhdGlvbiBwdXJwb3NlcyAtIGluIHByb2R1Y3Rpb24gdGhpcyB3b3VsZCBiZSByZXN0cmljdGVkKVxuICovXG5leHBvcnQgY29uc3QgYWlUcmlnZ2Vyc0FQSSA9IHtcbiAgLyoqXG4gICAqIEdldCBBSSB0cmlnZ2VycyBmb3IgYSBzcGVjaWZpYyB0aWNrZXJcbiAgICovXG4gIGdldEJ5VGlja2VyOiAodGlja2VyOiBzdHJpbmcpID0+IFxuICAgIGZldGNoQVBJPHsgZXZlbnRzOiBhbnlbXSB9PihgL2FwaS9haS10cmlnZ2Vycy8ke3RpY2tlcn1gKSxcbiAgICBcbiAgLyoqXG4gICAqIFNlbmQgYSB0ZXN0IG5vdGlmaWNhdGlvbiAoZGV2ZWxvcG1lbnQgb25seSlcbiAgICovXG4gIHNlbmRUZXN0Tm90aWZpY2F0aW9uOiAoZGF0YToge1xuICAgIHRpY2tlcjogc3RyaW5nO1xuICAgIGV2ZW50VHlwZTogc3RyaW5nO1xuICAgIGRldGFpbHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICB9KSA9PiBcbiAgICBmZXRjaEFQSTx7IHN0YXR1czogc3RyaW5nIH0+KCcvYXBpL25vdGlmaWNhdGlvbnMvdGVzdCcsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSksXG4gICAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0ZXN0IEFJIHRyaWdnZXIgKGRldmVsb3BtZW50L2RlbW8gcHVycG9zZXMgb25seSlcbiAgICovXG4gIGNyZWF0ZVRlc3RUcmlnZ2VyOiAoZGF0YToge1xuICAgIHRpY2tlcjogc3RyaW5nO1xuICAgIGV2ZW50VHlwZTogc3RyaW5nO1xuICAgIGZ1bmQ/OiBzdHJpbmc7XG4gICAgc2hhcmVzPzogbnVtYmVyO1xuICAgIHNoYXJlc192YWx1ZT86IG51bWJlcjtcbiAgICBpbnZlc3Rvcj86IHN0cmluZztcbiAgICBzb3VyY2U/OiBzdHJpbmc7XG4gIH0pID0+IFxuICAgIGZldGNoQVBJPHsgc3RhdHVzOiBzdHJpbmc7IG1lc3NhZ2U6IHN0cmluZzsgZGF0YTogYW55IH0+KCcvYXBpL2FpLXRyaWdnZXJzL3Rlc3QnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pLFxufTtcblxuLyoqXG4gKiBFY29ub21pYyBSZXBvcnRzIEFQSVxuICovXG5leHBvcnQgY29uc3QgZWNvbm9taWNSZXBvcnRzQVBJID0ge1xuICAvKipcbiAgICogR2V0IHJlY2VudCBlY29ub21pYyByZXBvcnRzXG4gICAqL1xuICBnZXRSZWNlbnQ6IChsaW1pdCA9IDEwKSA9PiBcbiAgICBmZXRjaEFQSTx7IGRhdGE6IEVjb25vbWljUmVwb3J0W10gfT4oYC9hcGkvZWNvbm9taWMtcmVwb3J0cy9yZWNlbnQ/bGltaXQ9JHtsaW1pdH1gKSxcbiAgICBcbiAgLyoqXG4gICAqIEdldCBlY29ub21pYyByZXBvcnRzIGJ5IHNvdXJjZVxuICAgKi9cbiAgZ2V0QnlTb3VyY2U6IChzb3VyY2U6IHN0cmluZywgbGltaXQgPSAxMCkgPT4gXG4gICAgZmV0Y2hBUEk8eyBkYXRhOiBFY29ub21pY1JlcG9ydFtdIH0+KGAvYXBpL2Vjb25vbWljLXJlcG9ydHMvcmVjZW50P3NvdXJjZT0ke3NvdXJjZX0mbGltaXQ9JHtsaW1pdH1gKSxcbiAgICBcbiAgLyoqXG4gICAqIEdldCBlY29ub21pYyByZXBvcnRzIGJ5IGNhdGVnb3J5XG4gICAqL1xuICBnZXRCeUNhdGVnb3J5OiAoY2F0ZWdvcnk6IHN0cmluZywgbGltaXQgPSAxMCkgPT4gXG4gICAgZmV0Y2hBUEk8eyBkYXRhOiBFY29ub21pY1JlcG9ydFtdIH0+KGAvYXBpL2Vjb25vbWljLXJlcG9ydHMvcmVjZW50P2NhdGVnb3J5PSR7Y2F0ZWdvcnl9JmxpbWl0PSR7bGltaXR9YCksXG4gICAgXG4gIC8qKlxuICAgKiBHZXQgYXZhaWxhYmxlIGVjb25vbWljIHJlcG9ydCBzb3VyY2VzXG4gICAqL1xuICBnZXRTb3VyY2VzOiAoKSA9PiBcbiAgICBmZXRjaEFQSTx7IGRhdGE6IHN0cmluZ1tdIH0+KCcvYXBpL2Vjb25vbWljLXJlcG9ydHMvc291cmNlcycpLFxuICAgIFxuICAvKipcbiAgICogR2V0IGF2YWlsYWJsZSBlY29ub21pYyByZXBvcnQgY2F0ZWdvcmllc1xuICAgKi9cbiAgZ2V0Q2F0ZWdvcmllczogKCkgPT4gXG4gICAgZmV0Y2hBUEk8eyBkYXRhOiBzdHJpbmdbXSB9PignL2FwaS9lY29ub21pYy1yZXBvcnRzL2NhdGVnb3JpZXMnKSxcbn07XG5cbi8qKlxuICogSW50ZXJ2aWV3cyBBUElcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVydmlld3NBUEkgPSB7XG4gIC8qKlxuICAgKiBHZXQgcmVjZW50IGludGVydmlld3NcbiAgICovXG4gIGdldFJlY2VudDogKGxpbWl0ID0gMTApID0+IFxuICAgIGZldGNoQVBJPHsgZGF0YTogSW50ZXJ2aWV3W10gfT4oYC9hcGkvaW50ZXJ2aWV3cy9yZWNlbnQ/bGltaXQ9JHtsaW1pdH1gKSxcbiAgICBcbiAgLyoqXG4gICAqIEdldCBpbnRlcnZpZXdzIGJ5IHNwZWFrZXJcbiAgICovXG4gIGdldEJ5U3BlYWtlcjogKHNwZWFrZXI6IHN0cmluZywgbGltaXQgPSAxMCkgPT4gXG4gICAgZmV0Y2hBUEk8eyBkYXRhOiBJbnRlcnZpZXdbXSB9PihgL2FwaS9pbnRlcnZpZXdzL3JlY2VudD9zcGVha2VyPSR7c3BlYWtlcn0mbGltaXQ9JHtsaW1pdH1gKSxcbiAgICBcbiAgLyoqXG4gICAqIEdldCBhdmFpbGFibGUgaW50ZXJ2aWV3IHNwZWFrZXJzXG4gICAqL1xuICBnZXRTcGVha2VyczogKCkgPT4gXG4gICAgZmV0Y2hBUEk8eyBkYXRhOiBzdHJpbmdbXSB9PignL2FwaS9pbnRlcnZpZXdzL3NwZWFrZXJzJyksXG59OyAiXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJob3N0bmFtZSIsIndpbmRvdyIsImxvY2F0aW9uIiwiZmV0Y2hBUEkiLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJ1cmwiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJlIiwibWVzc2FnZSIsInN0YXR1cyIsIkVycm9yIiwiZXJyb3IiLCJUeXBlRXJyb3IiLCJzdG9ja1VwZGF0ZXNBUEkiLCJnZXRBbGwiLCJnZXRCeVRpY2tlciIsInRpY2tlciIsImNyZWF0ZSIsImRhdGEiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVzZXJQcmVmZXJlbmNlc0FQSSIsImdldCIsInVzZXJJZCIsIndhcm4iLCJ1c2VyUHJlZmVyZW5jZXMiLCJ1cGRhdGUiLCJtYXhSZXRyaWVzIiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsInJlc3VsdCIsImVyciIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsImFpVHJpZ2dlcnNBUEkiLCJzZW5kVGVzdE5vdGlmaWNhdGlvbiIsImNyZWF0ZVRlc3RUcmlnZ2VyIiwiZWNvbm9taWNSZXBvcnRzQVBJIiwiZ2V0UmVjZW50IiwibGltaXQiLCJnZXRCeVNvdXJjZSIsInNvdXJjZSIsImdldEJ5Q2F0ZWdvcnkiLCJjYXRlZ29yeSIsImdldFNvdXJjZXMiLCJnZXRDYXRlZ29yaWVzIiwiaW50ZXJ2aWV3c0FQSSIsImdldEJ5U3BlYWtlciIsInNwZWFrZXIiLCJnZXRTcGVha2VycyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

}]);